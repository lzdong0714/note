原子性：
	事务不能被中断，要么完成，要么回滚。
	以实现一些加法，减法原子操作。(注意 --i、++i不是原子操作，其中包含有3个操作步骤：第一步，读取i；第二步，加1或减1；第三步：写回内存
	问题是一个变量会被多个线程访问（同一个资源会被多个用户访问，火车抢票 total--，这里有三个步骤但是却有N个用户访问）

可见性：
	可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
	//线程1执行的代码
	int i = 0;
	i = 10;

	//线程2执行的代码
	j = i;
　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。

　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。	


CPU --> 高速缓存 --> 主存（物理内存）
多线程的时候就是：
i=i+1
 		 			缓存-1 -->	CPU-1 -->缓存-1 -->
  				/	i=0			i+1			1		\
主存（共享变量i=0)										i=1
  				\\ 									/		
  					缓存-2 -->	CPU-2 -->缓存-2 -->
  					i=0			i+1			1			
以上就是缓存一致性问题。
	1 加lock 
	2 线程1 2之间通行MESI协议

Java 内存模型
	Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存
	Java中对原子性，有序性，可见性的保证：
		1 Java内存只对简单的读取，赋值才是原子操作
		2 可见性用volatile关键字来保证，当以一个共享变量被volatile修饰时，他会保证修改的值立刻更新到主存中，当有其他线程读取时，他会去内存中读取新值。通过synchronized和Lock保证同一时刻只有一个线程执行同步代码块，
		3 同样通过volatile 和synchronize和Lock来保证有序性。
		 　下面就来具体介绍下happens-before原则（先行发生原则）：

程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始


　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
		对共享变量的修改会写入内存中，并且使其他线程使用该变量的高速缓存无效化，强迫去读取新的内存值，从而刷新值。
　　2）禁止进行指令重排序


private static final long serialVersionUID = -1672970955045193907L;
	1.忽略SUID,相当于运行期间类的版本上的序列化和反序列上面没有差异。

	2.写一个默认的SUID,这就好像线程头部。告诉JVM所有版本中有着同样SUID的都是同一个版本。
	
	3.复制之前版本类的SUID。运行期间这个版本和之前版本是一样的版本。
	
	4.使用类每个版本生成的SUID。如果SUID与新版本的类不同，那么运行期间两个版本是不同的，并且老版本类序列化后的实例并不可以反序列成新的类的实例。




### JDK查看JVM命令

``` sh
#查找文件夹
find /path -name 'dirname*' -type d
$ find /usr -name 'jdk*' -type d
$ usr/jdk1.8/bin
# 这里又许多Java用的命令
# 查看jstat命令参数
$ jstat -option
jstat [-option] pid
$ jstat -class 17036
# 查看JVM的Heap使用
jmap -heap pid

# 如果出现权限问题可能是文件程序不可用
chomd 777 jdk*

```



